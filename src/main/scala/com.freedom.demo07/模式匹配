1）match 是scala的表达式。它始终以值作为结果。
2）模式的种类：统配摸式 _ ,常量模式，变量模式
   构造器模式：如果模式名为样本类，这个模式式首先检查对象是该名程的样本类的成员。
   然后检查对象的构造器参数是否符合额外提供的模式的。
   序列模式：可以象匹配样本类那样匹配如List 或者array 这样的序列类型。
   元组模式: (a,b,c)可以匹配任意的元组模式。
   类型模式：当做类型测试和类型转换的

   变量绑定：变量名@模式
   模式守卫：语法的模式匹配不够精确。scala 要求模式线性的，模式变量仅允许在模式中出现一次。
             模式守卫开始于if
             case n:Int if 0 < n =>


3）scala中以小写字母开始的命名为比变量，以大写字母开头的为常量。但是 this.pi 加西限定前缀后为常量。
4)封闭类 sealed 为了保证模式匹配的完整性，让样本类的超类被封闭，封闭类除了类定义所在文件之外，不能再
  添加任何新的子类.

5)函数字面量又称lambda表达式，使用符号=>定义。函数字面量是一个对象，可以作为参数和返回值进行传递。

6） 函数的柯里化是指将一个接受n个参数的函数变成n个接受一个参数的函数。
    例如：
    原函数
    def  add (x:Int ,y:int) :Int = {return x+y }
    柯里化
    def add（x:Int）= (y:Int) =>x * y
    简化
    def add (x:Int)(y:Int) = {x * y}

    函数式编程中，函数是从参数到返回值的映射而非带有返回值的子程序；
    变量也知识一个量的别名而非内存中的存储端元
    函数式编程关系从输入到输出的映射，不关心具体执行过程。
    函数式编程的设计理念要满足练个特性：
    1.高阶函数，它允许函数进行复合，
    2.函数引用的透明性，它使得结构不依赖于具体执行步骤，只依赖于映射关系。
    结果只依赖输入不依赖上下文的特性成为引用的透明性。
    函数对外部变量的修改成为副作用，只通过参数和返回值与外界交互的函数成为纯函数。

    函数结果只依赖输入不依赖于上下文， 使得每个函数都是一个高度独立的单元， 便于进行单元测试和除错.
    函数结果不依赖于上下文也不修改上下文, 从而在并发编程中不需要考虑线程安全问题， 也就避免了线程安全问题带来的风险和开销. 这一特性使得函数式程序很容易部署于并行计算和分布式计算平台上.

7)高阶函数：
    函数字面量可以作为参数或者返回值，接受函数字面量作为参数的函数称为高阶函数。

8）偏应用函数，函数的参数部分已经确定。
   偏函数是一个数学概念，函数定义域中的部分值没有对应的值。
